//===- H2BLB64FastISel.cpp - H2BLB FastISel implementation ----------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines the H2BLB-specific support for the FastISel class. Some
// of the target-specific code is generated by tablegen in the file
// H2BLBGenFastISel.inc, which is #included here.
//
//===----------------------------------------------------------------------===//

#include "H2BLB.h" // For the declaration of H2BLB::createFastISel.
#include "H2BLBCallingConvention.h"
#include "H2BLBInstrInfo.h"
#include "H2BLBRegisterInfo.h" // For the register classes.
#include "llvm/CodeGen/FastISel.h"
#include "llvm/CodeGen/FunctionLoweringInfo.h"

using namespace llvm;

namespace {

class H2BLBFastISel final : public FastISel {
private:
  // Selection routines.
  bool selectRet(const Instruction &I);

  bool fastLowerArguments() override;

public:
  // Backend specific FastISel code.
  explicit H2BLBFastISel(FunctionLoweringInfo &FuncInfo,
                         const TargetLibraryInfo *LibInfo)
      : FastISel(FuncInfo, LibInfo, /*SkipTargetIndependentISel=*/true) {}

  bool fastSelectInstruction(const Instruction *I) override;

#include "H2BLBGenFastISel.inc"
};
} // end anonymous namespace.

bool H2BLBFastISel::fastSelectInstruction(const Instruction *I) {
  // Skip FastISel is we've been told so.
  if (TLI.fallBackToDAGISel(*I))
    return false;

  switch (I->getOpcode()) {
  default:
    break;
  case Instruction::Ret:
    return selectRet(*I);
  }

  // fall-back to target-independent instruction selection.
  return selectOperator(I, I->getOpcode());
}

bool H2BLBFastISel::selectRet(const Instruction &I) {
  if (!FuncInfo.CanLowerReturn)
    return false;

  const Function &F = *I.getParent()->getParent();

  // Give up on anything fancy.
  if (F.isVarArg())
    return false;
  if (TLI.supportSplitCSR(FuncInfo.MF))
    return false;

  // Build a list of return value registers.
  SmallVector<Register, 4> RetRegs;

  const ReturnInst &Ret = cast<ReturnInst>(I);
  if (Ret.getNumOperands() > 0) {
    SmallVector<CCValAssign> RetValLocs;
    MachineFunction &MF = *FuncInfo.MF;
    CallingConv::ID CCID = F.getCallingConv();

    CCState CCInfo(CCID, F.isVarArg(), MF, RetValLocs, Ret.getContext());

    SmallVector<ISD::OutputArg, 4> Outs;

    GetReturnInfo(CCID, F.getReturnType(), F.getAttributes(), Outs, TLI, DL);
    CCInfo.AnalyzeReturn(Outs, RetCC_H2BLB_Common);

    // Copy the result values into the output registers.
    for (size_t i = 0; i != RetValLocs.size(); ++i) {
      CCValAssign &VA = RetValLocs[i];
      if (!VA.isRegLoc() || VA.getLocInfo() != CCValAssign::Full)
        return false;

      const Value *RV = Ret.getReturnValue();
      Register SrcReg = getRegForValue(RV);
      if (SrcReg == H2BLB::NoRegister)
        return false;

      Register DestReg = VA.getLocReg();
      // Copy the virtual register to the desired physical register.
      BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, MIMD,
              TII.get(TargetOpcode::COPY), DestReg)
          .addReg(SrcReg);

      RetRegs.push_back(VA.getLocReg());
    }
  }

  MachineInstrBuilder MIB =
      BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, MIMD, TII.get(H2BLB::RETURN));

  for (Register RetReg : RetRegs)
    MIB.addReg(RetReg, RegState::Implicit);

  return true;
}

FastISel *H2BLB::createFastISel(FunctionLoweringInfo &FuncInfo,
                                const TargetLibraryInfo *LibInfo) {

  return new H2BLBFastISel(FuncInfo, LibInfo);
}

bool H2BLBFastISel::fastLowerArguments() {
  if (!FuncInfo.CanLowerReturn)
    return false;

  const Function *F = FuncInfo.Fn;
  if (F->isVarArg())
    return false;

  CallingConv::ID CC = F->getCallingConv();
  if (CC != CallingConv::C && CC != CallingConv::Fast)
    return false;

  // Success only if there are no argument to lower.
  return F->args().empty();
}
