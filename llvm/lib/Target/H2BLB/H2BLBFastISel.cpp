//===- H2BLB64FastISel.cpp - H2BLB FastISel implementation ----------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines the H2BLB-specific support for the FastISel class. Some
// of the target-specific code is generated by tablegen in the file
// H2BLBGenFastISel.inc, which is #included here.
//
//===----------------------------------------------------------------------===//

#include "H2BLB.h" // For the declaration of H2BLB::createFastISel.
#include "H2BLBCallingConvention.h"
#include "H2BLBInstrInfo.h"
#include "H2BLBRegisterInfo.h" // For the register classes.
#include "llvm/CodeGen/FastISel.h"
#include "llvm/CodeGen/FunctionLoweringInfo.h"

using namespace llvm;

namespace {

class H2BLBFastISel final : public FastISel {
private:
  // Selection routines.
  bool selectRet(const Instruction &I);

  bool fastLowerArguments() override;

public:
  // Backend specific FastISel code.
  explicit H2BLBFastISel(FunctionLoweringInfo &FuncInfo,
                         const TargetLibraryInfo *LibInfo)
      : FastISel(FuncInfo, LibInfo, /*SkipTargetIndependentISel=*/true) {}

  bool fastSelectInstruction(const Instruction *I) override;

#include "H2BLBGenFastISel.inc"
};
} // end anonymous namespace.

bool H2BLBFastISel::fastSelectInstruction(const Instruction *I) {
  // Skip FastISel is we've been told so.
  if (TLI.fallBackToDAGISel(*I))
    return false;

  switch (I->getOpcode()) {
  default:
    break;
  case Instruction::Ret:
    return selectRet(*I);
  }

  // fall-back to target-independent instruction selection.
  return selectOperator(I, I->getOpcode());
}

bool H2BLBFastISel::selectRet(const Instruction &I) {
  if (!FuncInfo.CanLowerReturn)
    return false;

  const Function &F = *I.getParent()->getParent();

  // Give up on anything fancy.
  if (F.isVarArg())
    return false;
  if (TLI.supportSplitCSR(FuncInfo.MF))
    return false;

  // Build a list of return value registers.
  SmallVector<Register, 4> RetRegs;

  const ReturnInst &Ret = cast<ReturnInst>(I);
  if (Ret.getNumOperands() > 0) {
    SmallVector<CCValAssign> RetValLocs;
    MachineFunction &MF = *FuncInfo.MF;
    CallingConv::ID CCID = F.getCallingConv();

    CCState CCInfo(CCID, F.isVarArg(), MF, RetValLocs, Ret.getContext());

    SmallVector<ISD::OutputArg, 4> Outs;

    GetReturnInfo(CCID, F.getReturnType(), F.getAttributes(), Outs, TLI, DL);
    CCInfo.AnalyzeReturn(Outs, RetCC_H2BLB_Common);

    // Copy the result values into the output registers.
    for (size_t i = 0; i != RetValLocs.size(); ++i) {
      CCValAssign &VA = RetValLocs[i];
      if (!VA.isRegLoc() || VA.getLocInfo() != CCValAssign::Full)
        return false;

      const Value *RV = Ret.getReturnValue();
      Register SrcReg = getRegForValue(RV);
      if (SrcReg == H2BLB::NoRegister)
        return false;

      Register DestReg = VA.getLocReg();
      // Copy the virtual register to the desired physical register.
      BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, MIMD,
              TII.get(TargetOpcode::COPY), DestReg)
          .addReg(SrcReg);

      RetRegs.push_back(VA.getLocReg());
    }
  }

  MachineInstrBuilder MIB =
      BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, MIMD, TII.get(H2BLB::RETURN));

  for (Register RetReg : RetRegs)
    MIB.addReg(RetReg, RegState::Implicit);

  return true;
}

FastISel *H2BLB::createFastISel(FunctionLoweringInfo &FuncInfo,
                                const TargetLibraryInfo *LibInfo) {

  return new H2BLBFastISel(FuncInfo, LibInfo);
}

bool H2BLBFastISel::fastLowerArguments() {
  if (!FuncInfo.CanLowerReturn)
    return false;

  const Function *F = FuncInfo.Fn;
  if (F->isVarArg())
    return false;

  CallingConv::ID CC = F->getCallingConv();
  if (CC != CallingConv::C && CC != CallingConv::Fast)
    return false;

  // If we have more than one i32 + one i16, or three i16, we can't lower
  // with registers alone.
  const DataLayout &DL = F->getDataLayout();
  unsigned Nb16BitValues = 0;
  unsigned Nb32BitValues = 0;
  for (const Argument &Arg : F->args()) {
    Type *ArgTy = Arg.getType();
    TypeSize TySize = DL.getTypeSizeInBits(ArgTy);
    switch (TySize) {
    case 16:
      ++Nb16BitValues;
      break;
    case 32:
      ++Nb32BitValues;
      break;
    default:
      return false;
    }
  }

  // Check that we would have enough registers to fit everything.
  if (Nb32BitValues > 1)
    return false;

  Nb16BitValues += Nb32BitValues * 2;
  if (Nb16BitValues > 3)
    return false;

  static const MCPhysReg GPR16Registers[] = {H2BLB::R1, H2BLB::R2, H2BLB::R3};
  static const MCPhysReg GPR32Registers[] = {H2BLB::D1};

  MachineFunction &MF = *FuncInfo.MF;
  uint64_t NextAvailableGPR16 = 0;
  uint64_t NextAvailableGPR32 = 0;
  for (const Argument &Arg : F->args()) {
    Type *ArgTy = Arg.getType();
    TypeSize TySize = DL.getTypeSizeInBits(ArgTy);
    Register SrcPhysReg;
    const TargetRegisterClass *DstRC;
    switch (TySize) {
    case 16:
      assert(NextAvailableGPR16 <
                 sizeof(GPR16Registers) / sizeof(GPR16Registers[0]) &&
             "out-of-bound");
      SrcPhysReg = GPR16Registers[NextAvailableGPR16++];
      DstRC = &H2BLB::GPR16RegClass;
      break;
    case 32:
      assert(NextAvailableGPR32 <
                 sizeof(GPR32Registers) / sizeof(GPR32Registers[0]) &&
             "out-of-bound");
      SrcPhysReg = GPR32Registers[NextAvailableGPR32++];
      DstRC = &H2BLB::GPR32RegClass;
      break;
    default:
      llvm_unreachable("this should have been filtered out before");
    }

    // This is a quirk of how SDISel connect with FastISel.
    Register SrcReg = MF.addLiveIn(SrcPhysReg, DstRC);
    Register ResultReg = createResultReg(DstRC);
    BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, MIMD, TII.get(TargetOpcode::COPY),
            ResultReg)
        .addReg(SrcReg, getKillRegState(true));
    updateValueMap(&Arg, ResultReg);
  }

  return true;
}
