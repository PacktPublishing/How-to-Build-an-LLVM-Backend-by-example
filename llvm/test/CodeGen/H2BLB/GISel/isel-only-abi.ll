; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
; RUN: llc  -o - %s -global-isel -global-isel-abort=1 --stop-after=finalize-isel -verify-machineinstrs | FileCheck %s
target triple="h2blb--darwin"

define void @empty() {
  ; CHECK-LABEL: name: empty
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r0
  ret void
}

; Check that we directly select the non-pseudo instruction
; when the immediate is in the [0,127] range.
define i16 @retCstInRange() {
  ; CHECK-LABEL: name: retCstInRange
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[LD16imm7_:%[0-9]+]]:gpr16 = LD16imm7 11
  ; CHECK-NEXT:   $r1 = COPY [[LD16imm7_]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r1, implicit $r0
  ret i16 11
}

; Check that we select the pseudo instruction for out-of-range
; constants. The pseudo instruction will need to be fixed
; eventually.
define i16 @retCst() {
  ; CHECK-LABEL: name: retCst
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[LD16imm7_:%[0-9]+]]:gpr16 = LD16imm7 1
  ; CHECK-NEXT:   [[LD16imm7_1:%[0-9]+]]:gpr16 = LD16imm7 7
  ; CHECK-NEXT:   [[SHL16rr:%[0-9]+]]:gpr16 = SHL16rr [[LD16imm7_]], [[LD16imm7_1]]
  ; CHECK-NEXT:   [[LD16imm7_2:%[0-9]+]]:gpr16 = LD16imm7 4
  ; CHECK-NEXT:   [[OR16rr:%[0-9]+]]:gpr16 = OR16rr [[SHL16rr]], [[LD16imm7_2]]
  ; CHECK-NEXT:   $r1 = COPY [[OR16rr]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r1, implicit $r0
  ret i16 132
}

define i16 @oneArgi16(i16 %arg) {
  ; CHECK-LABEL: name: oneArgi16
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   $r1 = COPY [[COPY1]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r1, implicit $r0
  ret i16 %arg
}

define half @oneArgHalf(half %arg) {
  ; CHECK-LABEL: name: oneArgHalf
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   $r1 = COPY [[COPY1]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r1, implicit $r0
  ret half %arg
}

define i32 @oneArgi32(i32 %arg) {
  ; CHECK-LABEL: name: oneArgi32
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $d1, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr32 = COPY $d1
  ; CHECK-NEXT:   $d1 = COPY [[COPY1]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $d1, implicit $r0
  ret i32 %arg
}

define <2 x i16> @oneArgv2i16(<2 x i16> %arg) {
  ; CHECK-LABEL: name: oneArgv2i16
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $d1, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr32 = COPY $d1
  ; CHECK-NEXT:   $d1 = COPY [[COPY1]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $d1, implicit $r0
  ret <2 x i16> %arg
}

define <2 x i16> @twoArgsi16(i16 %arg, i16 %arg1) {
  ; CHECK-LABEL: name: twoArgsi16
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r2, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:gpr16 = COPY $r2
  ; CHECK-NEXT:   [[REG_SEQUENCE:%[0-9]+]]:gpr32 = REG_SEQUENCE [[COPY1]], %subreg.sub_low16, [[COPY2]], %subreg.sub_high16
  ; CHECK-NEXT:   $d1 = COPY [[REG_SEQUENCE]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $d1, implicit $r0
  %partial = insertelement <2 x i16> poison, i16 %arg, i32 0
  %res = insertelement <2 x i16> %partial, i16 %arg1, i32 1
  ret <2 x i16> %res
}

; The fourth i16 argument is expected to be passed through a stack slot.
define i16 @fourArgsi16(i16 %arg, i16 %arg1, i16 %arg2, i16 %arg3) {
  ; CHECK-LABEL: name: fourArgsi16
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r2, $r3, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[LDRSP16_:%[0-9]+]]:gpr16 = LDRSP16 %fixed-stack.0, 0 :: (invariant load (s16) from %fixed-stack.0, align 8)
  ; CHECK-NEXT:   $r1 = COPY [[LDRSP16_]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r1, implicit $r0
  ret i16 %arg3
}

; Check that we properly set r1 as the input argument for the call.
define i16 @callAFctWithOneArg(i16 %arg) {
  ; CHECK-LABEL: name: callAFctWithOneArg
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   $r1 = COPY [[COPY1]]
  ; CHECK-NEXT:   CALL @oneArgi16, csr, implicit-def $r0, implicit $sp, implicit $r1, implicit-def $r1
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   $r1 = COPY [[COPY2]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r1, implicit $r0
  %res = call i16 @oneArgi16(i16 %arg)
  ret i16 %res
}

declare i16 @arg16_32(i16, i32)

; Check that we set r1 and d1 as the input argument for the call.
define i16 @callAFctWithArg16_32(i16 %arg, i32 %arg1) {
  ; CHECK-LABEL: name: callAFctWithArg16_32
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $d1, $r1, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:gpr32 = COPY $d1
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   $r1 = COPY [[COPY1]]
  ; CHECK-NEXT:   $d1 = COPY [[COPY2]]
  ; CHECK-NEXT:   CALL @arg16_32, csr, implicit-def $r0, implicit $sp, implicit $r1, implicit $d1, implicit-def $r1
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   $r1 = COPY [[COPY3]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r1, implicit $r0
  %res = call i16 @arg16_32(i16 %arg, i32 %arg1)
  ret i16 %res
}

declare i16 @arg16_16(i16, i16)

; Check that we swap the input arg r1, r2 to r2, r1 to match the
; desired argument sequence.
define i16 @callAFctWithTwoI16Arg(i16 %arg, i16 %arg1) {
  ; CHECK-LABEL: name: callAFctWithTwoI16Arg
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r2, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:gpr16 = COPY $r2
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   $r1 = COPY [[COPY2]]
  ; CHECK-NEXT:   $r2 = COPY [[COPY1]]
  ; CHECK-NEXT:   CALL @arg16_16, csr, implicit-def $r0, implicit $sp, implicit $r1, implicit $r2, implicit-def $r1
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   $r1 = COPY [[COPY3]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r1, implicit $r0
  %res = call i16 @arg16_16(i16 %arg1, i16 %arg)
  ret i16 %res
}

declare i16 @lotsOfArgs2(i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16)

; Check that we duplicate %arg on as many stack slots as
; required to call lotsOfArgs1.
define i16 @foo1(i16 %arg) {
  ; CHECK-LABEL: name: foo1
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 16, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   STRSP16 [[COPY1]], $sp, 0 :: (store (s16) into stack, align 1)
  ; CHECK-NEXT:   STRSP16 [[COPY1]], $sp, 2 :: (store (s16) into stack + 2, align 1)
  ; CHECK-NEXT:   STRSP16 [[COPY1]], $sp, 4 :: (store (s16) into stack + 4, align 1)
  ; CHECK-NEXT:   STRSP16 [[COPY1]], $sp, 6 :: (store (s16) into stack + 6, align 1)
  ; CHECK-NEXT:   STRSP16 [[COPY1]], $sp, 8 :: (store (s16) into stack + 8, align 1)
  ; CHECK-NEXT:   STRSP16 [[COPY1]], $sp, 10 :: (store (s16) into stack + 10, align 1)
  ; CHECK-NEXT:   STRSP16 [[COPY1]], $sp, 12 :: (store (s16) into stack + 12, align 1)
  ; CHECK-NEXT:   STRSP16 [[COPY1]], $sp, 14 :: (store (s16) into stack + 14, align 1)
  ; CHECK-NEXT:   $r1 = COPY [[COPY1]]
  ; CHECK-NEXT:   $r2 = COPY [[COPY1]]
  ; CHECK-NEXT:   $r3 = COPY [[COPY1]]
  ; CHECK-NEXT:   CALL @lotsOfArgs1, csr, implicit-def $r0, implicit $sp, implicit $r1, implicit $r2, implicit $r3, implicit-def $r1
  ; CHECK-NEXT:   ADJCALLSTACKUP 16, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   $r1 = COPY [[COPY2]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r1, implicit $r0
   %res = call i16 @lotsOfArgs1(i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg)
   ret i16 %res
}

; Stress test for the stack lowering.
define i16 @lotsOfArgs1(i16 %a1, i16 %a2, i16 %a3, i16 %a4, i16 %a5, i16 %a6, i16 %a7, i16 %a8, i16 %a9, i16 %a10, i16 %a11) {
  ; CHECK-LABEL: name: lotsOfArgs1
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r2, $r3, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:gpr16 = COPY $r2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:gpr16 = COPY $r3
  ; CHECK-NEXT:   [[LDRSP16_:%[0-9]+]]:gpr16 = LDRSP16 %fixed-stack.7, 0 :: (invariant load (s16) from %fixed-stack.7, align 8)
  ; CHECK-NEXT:   [[LDRSP16_1:%[0-9]+]]:gpr16 = LDRSP16 %fixed-stack.6, 0 :: (invariant load (s16) from %fixed-stack.6)
  ; CHECK-NEXT:   [[LDRSP16_2:%[0-9]+]]:gpr16 = LDRSP16 %fixed-stack.5, 0 :: (invariant load (s16) from %fixed-stack.5, align 4)
  ; CHECK-NEXT:   [[LDRSP16_3:%[0-9]+]]:gpr16 = LDRSP16 %fixed-stack.4, 0 :: (invariant load (s16) from %fixed-stack.4)
  ; CHECK-NEXT:   [[LDRSP16_4:%[0-9]+]]:gpr16 = LDRSP16 %fixed-stack.3, 0 :: (invariant load (s16) from %fixed-stack.3, align 8)
  ; CHECK-NEXT:   [[LDRSP16_5:%[0-9]+]]:gpr16 = LDRSP16 %fixed-stack.2, 0 :: (invariant load (s16) from %fixed-stack.2)
  ; CHECK-NEXT:   [[LDRSP16_6:%[0-9]+]]:gpr16 = LDRSP16 %fixed-stack.1, 0 :: (invariant load (s16) from %fixed-stack.1, align 4)
  ; CHECK-NEXT:   [[LDRSP16_7:%[0-9]+]]:gpr16 = LDRSP16 %fixed-stack.0, 0 :: (invariant load (s16) from %fixed-stack.0)
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 16, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   STRSP16 [[LDRSP16_]], $sp, 0 :: (store (s16) into stack, align 1)
  ; CHECK-NEXT:   STRSP16 [[LDRSP16_1]], $sp, 2 :: (store (s16) into stack + 2, align 1)
  ; CHECK-NEXT:   STRSP16 [[LDRSP16_2]], $sp, 4 :: (store (s16) into stack + 4, align 1)
  ; CHECK-NEXT:   STRSP16 [[LDRSP16_3]], $sp, 6 :: (store (s16) into stack + 6, align 1)
  ; CHECK-NEXT:   STRSP16 [[LDRSP16_4]], $sp, 8 :: (store (s16) into stack + 8, align 1)
  ; CHECK-NEXT:   STRSP16 [[LDRSP16_5]], $sp, 10 :: (store (s16) into stack + 10, align 1)
  ; CHECK-NEXT:   STRSP16 [[LDRSP16_6]], $sp, 12 :: (store (s16) into stack + 12, align 1)
  ; CHECK-NEXT:   STRSP16 [[LDRSP16_7]], $sp, 14 :: (store (s16) into stack + 14, align 1)
  ; CHECK-NEXT:   $r1 = COPY [[COPY1]]
  ; CHECK-NEXT:   $r2 = COPY [[COPY2]]
  ; CHECK-NEXT:   $r3 = COPY [[COPY3]]
  ; CHECK-NEXT:   CALL @lotsOfArgs2, csr, implicit-def $r0, implicit $sp, implicit $r1, implicit $r2, implicit $r3, implicit-def $r1
  ; CHECK-NEXT:   ADJCALLSTACKUP 16, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 16, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   STRSP16 [[LDRSP16_4]], $sp, 0 :: (store (s16) into stack, align 1)
  ; CHECK-NEXT:   STRSP16 [[LDRSP16_3]], $sp, 2 :: (store (s16) into stack + 2, align 1)
  ; CHECK-NEXT:   STRSP16 [[LDRSP16_2]], $sp, 4 :: (store (s16) into stack + 4, align 1)
  ; CHECK-NEXT:   STRSP16 [[LDRSP16_1]], $sp, 6 :: (store (s16) into stack + 6, align 1)
  ; CHECK-NEXT:   STRSP16 [[LDRSP16_]], $sp, 8 :: (store (s16) into stack + 8, align 1)
  ; CHECK-NEXT:   STRSP16 [[COPY3]], $sp, 10 :: (store (s16) into stack + 10, align 1)
  ; CHECK-NEXT:   STRSP16 [[COPY2]], $sp, 12 :: (store (s16) into stack + 12, align 1)
  ; CHECK-NEXT:   STRSP16 [[COPY1]], $sp, 14 :: (store (s16) into stack + 14, align 1)
  ; CHECK-NEXT:   $r1 = COPY [[LDRSP16_7]]
  ; CHECK-NEXT:   $r2 = COPY [[LDRSP16_6]]
  ; CHECK-NEXT:   $r3 = COPY [[LDRSP16_5]]
  ; CHECK-NEXT:   CALL @lotsOfArgs2, csr, implicit-def $r0, implicit $sp, implicit $r1, implicit $r2, implicit $r3, implicit-def $r1
  ; CHECK-NEXT:   ADJCALLSTACKUP 16, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   [[ADDi16rr:%[0-9]+]]:gpr16 = ADDi16rr [[COPY1]], [[COPY4]]
  ; CHECK-NEXT:   [[ADDi16rr1:%[0-9]+]]:gpr16 = ADDi16rr [[LDRSP16_6]], [[ADDi16rr]]
  ; CHECK-NEXT:   [[ADDi16rr2:%[0-9]+]]:gpr16 = ADDi16rr [[ADDi16rr1]], [[COPY5]]
  ; CHECK-NEXT:   $r1 = COPY [[ADDi16rr2]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r1, implicit $r0
  %tmp = call i16 @lotsOfArgs2(i16 %a1, i16 %a2, i16 %a3, i16 %a4, i16 %a5, i16 %a6, i16 %a7, i16 %a8, i16 %a9, i16 %a10, i16 %a11)
  %tmp0 = call i16 @lotsOfArgs2(i16 %a11, i16 %a10, i16 %a9, i16 %a8, i16 %a7, i16 %a6, i16 %a5, i16 %a4, i16 %a3, i16 %a2, i16 %a1)
  %tmp1 = add i16 %a1, %tmp
  %tmp2 = add i16 %a10, %tmp1
  %res = add i16 %tmp2, %tmp0
  ret i16 %res
}

; Lowering of structures.

%struct.nested = type { i8, { i8, i32 }, i32}

define i32 @structInputArg(%struct.nested %struct) {
  ; CHECK-LABEL: name: structInputArg
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r2, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[LDRSP32_:%[0-9]+]]:gpr32 = LDRSP32 %fixed-stack.1, 0 :: (invariant load (s32) from %fixed-stack.1, align 8)
  ; CHECK-NEXT:   $d1 = COPY [[LDRSP32_]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $d1, implicit $r0
  %res = extractvalue %struct.nested %struct, 1, 1
  ret i32 %res
}

define i32 @structOutArg() {
  ; CHECK-LABEL: name: structOutArg
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[LDRZEXTSP8_:%[0-9]+]]:gpr16 = LDRZEXTSP8 %stack.0.addr_input, 0 :: (dereferenceable load (s8) from %ir.addr_input, align 4)
  ; CHECK-NEXT:   [[LDRZEXTSP8_1:%[0-9]+]]:gpr16 = LDRZEXTSP8 %stack.0.addr_input, 4 :: (dereferenceable load (s8) from %ir.addr_input + 4, align 4)
  ; CHECK-NEXT:   [[LDRSP32_:%[0-9]+]]:gpr32 = LDRSP32 %stack.0.addr_input, 8 :: (dereferenceable load (s32) from %ir.addr_input + 8)
  ; CHECK-NEXT:   [[LDRSP32_1:%[0-9]+]]:gpr32 = LDRSP32 %stack.0.addr_input, 12 :: (dereferenceable load (s32) from %ir.addr_input + 12)
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   STRSP32 [[LDRSP32_]], $sp, 0 :: (store (s32) into stack, align 1)
  ; CHECK-NEXT:   STRSP32 [[LDRSP32_1]], $sp, 2 :: (store (s32) into stack + 2, align 1)
  ; CHECK-NEXT:   $r1 = COPY [[LDRZEXTSP8_]]
  ; CHECK-NEXT:   $r2 = COPY [[LDRZEXTSP8_1]]
  ; CHECK-NEXT:   CALL @structInputArg, csr, implicit-def $r0, implicit $sp, implicit $r1, implicit $r2, implicit-def $d1
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr32 = COPY $d1
  ; CHECK-NEXT:   $d1 = COPY [[COPY1]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $d1, implicit $r0
  %addr_input = alloca %struct.nested
  %input = load %struct.nested, ptr %addr_input
  %res = call i32 @structInputArg(%struct.nested %input)
  ret i32 %res
}

define %struct.nested @structReturn() {
  ; CHECK-LABEL: name: structReturn
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   [[LD16imm7_:%[0-9]+]]:gpr16 = LD16imm7 0
  ; CHECK-NEXT:   [[LD16imm7_1:%[0-9]+]]:gpr16 = LD16imm7 1
  ; CHECK-NEXT:   [[LD32imm7_:%[0-9]+]]:gpr32 = LD32imm7 2
  ; CHECK-NEXT:   [[LD32imm7_1:%[0-9]+]]:gpr32 = LD32imm7 3
  ; CHECK-NEXT:   TRUNCSTR8 [[LD16imm7_]], [[COPY1]], 0 :: (store (s8), align 8)
  ; CHECK-NEXT:   TRUNCSTR8 [[LD16imm7_1]], [[COPY1]], 4 :: (store (s8), align 4)
  ; CHECK-NEXT:   STR32 [[LD32imm7_]], [[COPY1]], 8 :: (store (s32), align 8)
  ; CHECK-NEXT:   STR32 [[LD32imm7_1]], [[COPY1]], 12 :: (store (s32))
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r0
  %struct1 = insertvalue %struct.nested undef, i8 0, 0
  %struct2 = insertvalue %struct.nested %struct1, i8 1, 1, 0
  %struct3 = insertvalue %struct.nested %struct2, i32 2, 1, 1
  %struct4 = insertvalue %struct.nested %struct3, i32 3, 2
  ret %struct.nested %struct4
}

define i32 @readStructReturn() {
  ; CHECK-LABEL: name: readStructReturn
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[MOVFROMSP:%[0-9]+]]:gpr16 = MOVFROMSP %stack.0
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   $r1 = COPY [[MOVFROMSP]]
  ; CHECK-NEXT:   CALL @structReturn, csr, implicit-def $r0, implicit $sp, implicit $r1
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[LDRSP32_:%[0-9]+]]:gpr32 = LDRSP32 %stack.0, 12 :: (load (s32) from %stack.0)
  ; CHECK-NEXT:   $d1 = COPY [[LDRSP32_]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $d1, implicit $r0
  %struct = call %struct.nested @structReturn()
  %res = extractvalue %struct.nested %struct, 2
  ret i32 %res
}
