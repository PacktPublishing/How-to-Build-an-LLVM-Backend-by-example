; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
; RUN: llc  -o - %s -fast-isel=0 --stop-after=finalize-isel -verify-machineinstrs | FileCheck %s
target triple="h2blb--"

define void @empty() {
  ; CHECK-LABEL: name: empty
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r0
  ret void
}

; Check that we directly select the non-pseudo instruction
; when the immediate is in the [0,127] range.
define i16 @retCstInRange() {
  ; CHECK-LABEL: name: retCstInRange
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[LD16imm7_:%[0-9]+]]:gpr16 = LD16imm7 11
  ; CHECK-NEXT:   $r1 = COPY [[LD16imm7_]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1
  ret i16 11
}

; Check that we select the pseudo instruction for out-of-range
; constants. The pseudo instruction will need to be fixed
; eventually.
define i16 @retCst() {
  ; CHECK-LABEL: name: retCst
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[LD16imm16_:%[0-9]+]]:gpr16 = LD16imm16 132
  ; CHECK-NEXT:   $r1 = COPY [[LD16imm16_]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1
  ret i16 132
}

define i16 @oneArgi16(i16 %arg) {
  ; CHECK-LABEL: name: oneArgi16
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   $r1 = COPY [[COPY1]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1
  ret i16 %arg
}

define half @oneArgHalf(half %arg) {
  ; CHECK-LABEL: name: oneArgHalf
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   $r1 = COPY [[COPY1]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1
  ret half %arg
}

define i32 @oneArgi32(i32 %arg) {
  ; CHECK-LABEL: name: oneArgi32
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $d1, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr32 = COPY $d1
  ; CHECK-NEXT:   $d1 = COPY [[COPY1]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $d1
  ret i32 %arg
}

define <2 x i16> @oneArgv2i16(<2 x i16> %arg) {
  ; CHECK-LABEL: name: oneArgv2i16
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r2, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr16 = COPY $r2
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   $r1 = COPY [[COPY2]]
  ; CHECK-NEXT:   $r2 = COPY [[COPY1]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1, implicit $r2
  ret <2 x i16> %arg
}

define <2 x i16> @twoArgsi16(i16 %arg, i16 %arg1) {
  ; CHECK-LABEL: name: twoArgsi16
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r2, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr16 = COPY $r2
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   $r1 = COPY [[COPY2]]
  ; CHECK-NEXT:   $r2 = COPY [[COPY1]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1, implicit $r2
  %partial = insertelement <2 x i16> poison, i16 %arg, i32 0
  %res = insertelement <2 x i16> %partial, i16 %arg1, i32 1
  ret <2 x i16> %res
}

; The fourth i16 argument is expected to be passed through a stack slot.
define i16 @fourArgsi16(i16 %arg, i16 %arg1, i16 %arg2, i16 %arg3) {
  ; CHECK-LABEL: name: fourArgsi16
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[LDRSP16_:%[0-9]+]]:gpr16 = LDRSP16 %fixed-stack.0, 0 :: (load (s16) from %fixed-stack.0, align 8)
  ; CHECK-NEXT:   $r1 = COPY [[LDRSP16_]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1
  ret i16 %arg3
}

; Check that we properly set r1 as the input argument for the call.
define i16 @callAFctWithOneArg(i16 %arg) {
  ; CHECK-LABEL: name: callAFctWithOneArg
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def dead $sp, implicit $sp
  ; CHECK-NEXT:   $r1 = COPY [[COPY1]]
  ; CHECK-NEXT:   CALL @oneArgi16, csr, implicit-def dead $r0, implicit $sp, implicit $r1, implicit-def $sp, implicit-def $r1
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def dead $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   $r1 = COPY [[COPY2]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1
  %res = call i16 @oneArgi16(i16 %arg)
  ret i16 %res
}

declare i16 @arg16_32(i16, i32)

; Check that we set r1 and d1 as the input argument for the call.
define i16 @callAFctWithArg16_32(i16 %arg, i32 %arg1) {
  ; CHECK-LABEL: name: callAFctWithArg16_32
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $d1, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr32 = COPY $d1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def dead $sp, implicit $sp
  ; CHECK-NEXT:   $r1 = COPY [[COPY2]]
  ; CHECK-NEXT:   $d1 = COPY [[COPY1]]
  ; CHECK-NEXT:   CALL @arg16_32, csr, implicit-def dead $r0, implicit $sp, implicit $r1, implicit $d1, implicit-def $sp, implicit-def $r1
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def dead $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   $r1 = COPY [[COPY3]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1
  %res = call i16 @arg16_32(i16 %arg, i32 %arg1)
  ret i16 %res
}

declare i16 @arg16_16(i16, i16)

; Check that we swap the input arg r1, r2 to r2, r1 to match the
; desired argument sequence.
define i16 @callAFctWithTwoI16Arg(i16 %arg, i16 %arg1) {
  ; CHECK-LABEL: name: callAFctWithTwoI16Arg
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r2, $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr16 = COPY $r0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr16 = COPY $r2
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def dead $sp, implicit $sp
  ; CHECK-NEXT:   $r1 = COPY [[COPY1]]
  ; CHECK-NEXT:   $r2 = COPY [[COPY2]]
  ; CHECK-NEXT:   CALL @arg16_16, csr, implicit-def dead $r0, implicit $sp, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r1
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def dead $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:gpr16 = COPY $r1
  ; CHECK-NEXT:   $r1 = COPY [[COPY3]]
  ; CHECK-NEXT:   $r0 = COPY [[COPY]]
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1
  %res = call i16 @arg16_16(i16 %arg1, i16 %arg)
  ret i16 %res
}
