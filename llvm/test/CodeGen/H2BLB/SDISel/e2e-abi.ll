; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -o - %s -fast-isel=0 -verify-machineinstrs | FileCheck %s
target triple="h2blb--"

define void @empty() {
; CHECK-LABEL: empty:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  ret void
}

define i16 @retCstInRange() {
; CHECK-LABEL: retCstInRange:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ldi16 r1, 11
; CHECK-NEXT:    ret
  ret i16 11
}

define i16 @oneArgi16(i16 %arg) {
; CHECK-LABEL: oneArgi16:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  ret i16 %arg
}

define half @oneArgHalf(half %arg) {
; CHECK-LABEL: oneArgHalf:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  ret half %arg
}

define i32 @oneArgi32(i32 %arg) {
; CHECK-LABEL: oneArgi32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  ret i32 %arg
}

define <2 x i16> @oneArgv2i16(<2 x i16> %arg) {
; CHECK-LABEL: oneArgv2i16:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  ret <2 x i16> %arg
}

define <2 x i16> @twoArgsi16(i16 %arg, i16 %arg1) {
; CHECK-LABEL: twoArgsi16:
; CHECK:       # %bb.0:
; CHECK-NEXT:    mov16 r3, r2
; CHECK-NEXT:    mov16 r2, r1
; CHECK-NEXT:    ret
  %partial = insertelement <2 x i16> poison, i16 %arg, i32 0
  %res = insertelement <2 x i16> %partial, i16 %arg1, i32 1
  ret <2 x i16> %res
}

; Check that we properly set r1 as the input argument for the call.
; The store and load are here to save and restore our link register.
define i16 @callAFctWithOneArg(i16 %arg) {
; CHECK-LABEL: callAFctWithOneArg:
; CHECK:       # %bb.0:
; CHECK-NEXT:    subsp sp, sp, 8
; CHECK-NEXT:    strsp32 d2, sp, 4 # 4-byte Folded Spill
; CHECK-NEXT:    mov16 r4, r0
; CHECK-NEXT:    call oneArgi16
; CHECK-NEXT:    mov16 r0, r4
; CHECK-NEXT:    ldrsp32 d2, sp, 4 # 4-byte Folded Reload
; CHECK-NEXT:    addsp sp, sp, 8
; CHECK-NEXT:    ret
  %res = call i16 @oneArgi16(i16 %arg)
  ret i16 %res
}

declare i16 @arg16_32(i16, i32)

; Check that we set r1 and d1 as the input argument for the call.
define i16 @callAFctWithArg16_32(i16 %arg, i32 %arg1) {
; CHECK-LABEL: callAFctWithArg16_32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    subsp sp, sp, 8
; CHECK-NEXT:    strsp32 d2, sp, 4 # 4-byte Folded Spill
; CHECK-NEXT:    mov16 r4, r0
; CHECK-NEXT:    call arg16_32
; CHECK-NEXT:    mov16 r0, r4
; CHECK-NEXT:    ldrsp32 d2, sp, 4 # 4-byte Folded Reload
; CHECK-NEXT:    addsp sp, sp, 8
; CHECK-NEXT:    ret
  %res = call i16 @arg16_32(i16 %arg, i32 %arg1)
  ret i16 %res
}

declare i16 @arg16_16(i16, i16)

define i16 @callAFctWithTwoI16Arg(i16 %arg, i16 %arg1) {
; CHECK-LABEL: callAFctWithTwoI16Arg:
; CHECK:       # %bb.0:
; CHECK-NEXT:    subsp sp, sp, 8
; CHECK-NEXT:    strsp32 d2, sp, 4 # 4-byte Folded Spill
; CHECK-NEXT:    mov16 r4, r0
; CHECK-NEXT:    call arg16_16
; CHECK-NEXT:    mov16 r0, r4
; CHECK-NEXT:    ldrsp32 d2, sp, 4 # 4-byte Folded Reload
; CHECK-NEXT:    addsp sp, sp, 8
; CHECK-NEXT:    ret
  %res = call i16 @arg16_16(i16 %arg, i16 %arg1)
  ret i16 %res
}

declare i16 @lotsOfArgs2(i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16)

; Check that we duplicate %arg on as many stack slots as
; required to call lotsOfArgs1.
define i16 @foo1(i16 %arg) {
; CHECK-LABEL: foo1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    subsp sp, sp, 24
; CHECK-NEXT:    strsp32 d2, sp, 20 # 4-byte Folded Spill
; CHECK-NEXT:    mov16 r4, r0
; CHECK-NEXT:    strsp16 r1, sp, 14
; CHECK-NEXT:    strsp16 r1, sp, 12
; CHECK-NEXT:    strsp16 r1, sp, 10
; CHECK-NEXT:    strsp16 r1, sp, 8
; CHECK-NEXT:    strsp16 r1, sp, 6
; CHECK-NEXT:    strsp16 r1, sp, 4
; CHECK-NEXT:    strsp16 r1, sp, 2
; CHECK-NEXT:    strsp16 r1, sp, 0
; CHECK-NEXT:    mov16 r2, r1
; CHECK-NEXT:    mov16 r3, r1
; CHECK-NEXT:    call lotsOfArgs1
; CHECK-NEXT:    mov16 r0, r4
; CHECK-NEXT:    ldrsp32 d2, sp, 20 # 4-byte Folded Reload
; CHECK-NEXT:    addsp sp, sp, 24
; CHECK-NEXT:    ret
   %res = call i16 @lotsOfArgs1(i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg)
   ret i16 %res
}

; Stress test for the stack lowering.
;
; At the entry of the function the stack looks like:
; high addr %a11  incoming stack arguments
;           ...
; low addr  %a4 <-- sp at the entry of bar1
;
; After the prologue, the space for the spill slots and the space for the
; arguments of lotsOfArgs2 is allocated:
;
; high addr
;   |   incoming stack arguments
;   |  ---- sp at the entry of lotsOfArgs1
;   |    spill slot 1  |
;   |    ...           |> spill slots
;   |    spill slot N  |
;   |  -----------------
;   |    space for the outgoing arguments space
;   |    This space will be used to store the arguments to lotsOfArgs2.
;   |    Since there are two calls to lotsOfArgs2, the content of this
;   |    space is different between each of them.
;   v  ---- sp after the prologue
; low addr
;
; We have 11 spill slots: 9 for 2-byte values and 2 for 4-byte values
;                         (the callee saved registers (CSRs))
; Why 9: a1-a11 needs to live through the first call of bar2
;         r0 is used for the link register
;         r1 r2 and r3 are used for the arguments
;         Therefore we can use r4-r7 to keep values alive
;         => this creates the 2 CSR spills
;         At this point we have 11 - 4 (i.e., a1-a11 minus what can be kept
;         in r4-r7); so still 7 values to spill.
;         Then since r0 is used as a link register for lotsOfArgs1 (current fct)
;         but also lotsOfArgs2, it needs to be saved and since there is no
;         register left this creates one more spill. So +1 here.
;         Then, %tmp needs to be alive through the second call to lotsOfArgs2.
;         Similarly to r0, there's no register left so one more spill. +1
; Therefore 2 CSR spills, then 7+2 spills.
;
; Finally, we allocate 48 bytes on the stacks.
; That's:
;   9 * 2 bytes for the spill slots.
; + 2 * 4 bytes for the CSRs.
; + 8 * 2 bytes for the outgoing arguments.
; = 42
; Since we want our stack to be aligned on 8 bytes, we have to push it to the
; next multiple of 8 => 48. Hence, we will insert 6 bytes of padding.
;
; The padding is added between the spill space and the outgoing arguments space.
;
; Here is a picture of the contain of the stack using the LLVM IR value names
; (or the register names for the CSRs.)
; --- incoming arg
; sp+62: a11
; sp+60: a10
; sp+58: a9
; sp+56: a8
; sp+54: a7
; sp+52: a6
; sp+50: a5
; sp+48: a4
; --- sp at the entry of the function
; sp+46: d2-high
; sp+44: d2-low
; sp+42: d1-high
; sp+40: d1-low
; sp+38: LR (r0)
; sp+36: a11
; sp+34: a10
; sp+32: a9
; sp+30: a8
; sp+28: a7
; sp+26: tmp
; sp+24: a1 (note the order for the spill slot doesn't matter)
; sp+22: a2
; sp+20: padding
; sp+18: padding
; sp+16: padding
; -- lotsOfArgs2 first call | second call
; sp+14: a11                | a1
; sp+12: a10                | a2
; sp+10: a9                 | a3
; sp+8:  a8                 | a4
; sp+6:  a7                 | a5
; sp+4:  a6                 | a6
; sp+2:  a5                 | a7
; sp+0:  a4                 | a8 <-- sp address after prologue
; ------------------------------------
; r3:    a3                 | a9
; r2:    a2                 | a10
; r1:    a1                 | a11
; ----
; Tagged ASM for checking that everything is correct.
; LHS is what is hold in the related location.
;	subsp	sp, sp, 48
; CSR	strsp16	d2, sp, 44                      # 4-byte Folded Spill
; CSR	strsp16	d3, sp, 40                      # 4-byte Folded Spill
; LR	strsp16	r0, sp, 38                      # 2-byte Folded Spill
; a3	mov16	r4, r3
; a2 	strsp16	r2, sp, 22                      # 2-byte Folded Spill
; a1	strsp16	r1, sp, 24                      # 2-byte Folded Spill
; a11 	ldrsp16	r0, sp, 62
; a11	strsp16	r0, sp, 36                      # 2-byte Folded Spill
; a11	strsp16	r0, sp, 14
; a10	ldrsp16	r0, sp, 60
; a10	strsp16	r0, sp, 34                      # 2-byte Folded Spill
; a10	strsp16	r0, sp, 12
; a9	ldrsp16	r0, sp, 58
; a9	strsp16	r0, sp, 32                      # 2-byte Folded Spill
; a9	strsp16	r0, sp, 10
; a8	ldrsp16	r0, sp, 56
; a8	strsp16	r0, sp, 30                      # 2-byte Folded Spill
; a8	strsp16	r0, sp, 8
; a7	ldrsp16	r0, sp, 54
; a7	strsp16	r0, sp, 28                      # 2-byte Folded Spill
; a7	strsp16	r0, sp, 6
; a6	ldrsp16	r7, sp, 52
; a6	strsp16	r7, sp, 4
; a5	ldrsp16	r5, sp, 50
; a5	strsp16	r5, sp, 2
; a4	ldrsp16	r6, sp, 48
; a4	strsp16	r6, sp, 0
;	call	lotsOfArgs2
; tmp	strsp16	r1, sp, 26                      # 2-byte Folded Spill
; a2	ldrsp16	r0, sp, 22                      # 2-byte Folded Reload
; a2	strsp16	r0, sp, 12
; a3	strsp16	r4, sp, 10
; a4	strsp16	r6, sp, 8
; a5	strsp16	r5, sp, 6
; a6	strsp16	r7, sp, 4
; a7	ldrsp16	r0, sp, 28                      # 2-byte Folded Reload
; a7	strsp16	r0, sp, 2
; a8	ldrsp16	r0, sp, 30                      # 2-byte Folded Reload
; a8	strsp16	r0, sp, 0
; a1	ldrsp16	r5, sp, 24                      # 2-byte Folded Reload
; a1	strsp16	r5, sp, 14
; a11	ldrsp16	r1, sp, 36                      # 2-byte Folded Reload
; a10	ldrsp16	r4, sp, 34                      # 2-byte Folded Reload
; a10	mov16	r2, r4
; a9	ldrsp16	r3, sp, 32                      # 2-byte Folded Reload
;	call	lotsOfArgs2
; tmp	ldrsp16	r0, sp, 26                      # 2-byte Folded Reload
; a1+	addi16	r0, r5, r0
; a10+	addi16	r0, r4, r0
;tmp0+	addi16	r1, r0, r1
; LR	ldrsp16	r0, sp, 38                      # 2-byte Folded Reload
; CSR	ldrsp16	d3, sp, 40                      # 4-byte Folded Reload
; CSR	ldrsp16	d2, sp, 44                      # 4-byte Folded Reload
;	addsp	sp, sp, 48
;	ret
define i16 @lotsOfArgs1(i16 %a1, i16 %a2, i16 %a3, i16 %a4, i16 %a5, i16 %a6, i16 %a7, i16 %a8, i16 %a9, i16 %a10, i16 %a11) {
; CHECK-LABEL: lotsOfArgs1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    subsp sp, sp, 48
; CHECK-NEXT:    strsp32 d2, sp, 44 # 4-byte Folded Spill
; CHECK-NEXT:    strsp32 d3, sp, 40 # 4-byte Folded Spill
; CHECK-NEXT:    strsp16 r0, sp, 38 # 2-byte Folded Spill
; CHECK-NEXT:    mov16 r4, r3
; CHECK-NEXT:    strsp16 r2, sp, 22 # 2-byte Folded Spill
; CHECK-NEXT:    strsp16 r1, sp, 24 # 2-byte Folded Spill
; CHECK-NEXT:    ldrsp16 r0, sp, 62
; CHECK-NEXT:    strsp16 r0, sp, 36 # 2-byte Folded Spill
; CHECK-NEXT:    strsp16 r0, sp, 14
; CHECK-NEXT:    ldrsp16 r0, sp, 60
; CHECK-NEXT:    strsp16 r0, sp, 34 # 2-byte Folded Spill
; CHECK-NEXT:    strsp16 r0, sp, 12
; CHECK-NEXT:    ldrsp16 r0, sp, 58
; CHECK-NEXT:    strsp16 r0, sp, 32 # 2-byte Folded Spill
; CHECK-NEXT:    strsp16 r0, sp, 10
; CHECK-NEXT:    ldrsp16 r0, sp, 56
; CHECK-NEXT:    strsp16 r0, sp, 30 # 2-byte Folded Spill
; CHECK-NEXT:    strsp16 r0, sp, 8
; CHECK-NEXT:    ldrsp16 r0, sp, 54
; CHECK-NEXT:    strsp16 r0, sp, 28 # 2-byte Folded Spill
; CHECK-NEXT:    strsp16 r0, sp, 6
; CHECK-NEXT:    ldrsp16 r7, sp, 52
; CHECK-NEXT:    strsp16 r7, sp, 4
; CHECK-NEXT:    ldrsp16 r5, sp, 50
; CHECK-NEXT:    strsp16 r5, sp, 2
; CHECK-NEXT:    ldrsp16 r6, sp, 48
; CHECK-NEXT:    strsp16 r6, sp, 0
; CHECK-NEXT:    call lotsOfArgs2
; CHECK-NEXT:    strsp16 r1, sp, 26 # 2-byte Folded Spill
; CHECK-NEXT:    ldrsp16 r0, sp, 22 # 2-byte Folded Reload
; CHECK-NEXT:    strsp16 r0, sp, 12
; CHECK-NEXT:    strsp16 r4, sp, 10
; CHECK-NEXT:    strsp16 r6, sp, 8
; CHECK-NEXT:    strsp16 r5, sp, 6
; CHECK-NEXT:    strsp16 r7, sp, 4
; CHECK-NEXT:    ldrsp16 r0, sp, 28 # 2-byte Folded Reload
; CHECK-NEXT:    strsp16 r0, sp, 2
; CHECK-NEXT:    ldrsp16 r0, sp, 30 # 2-byte Folded Reload
; CHECK-NEXT:    strsp16 r0, sp, 0
; CHECK-NEXT:    ldrsp16 r5, sp, 24 # 2-byte Folded Reload
; CHECK-NEXT:    strsp16 r5, sp, 14
; CHECK-NEXT:    ldrsp16 r1, sp, 36 # 2-byte Folded Reload
; CHECK-NEXT:    ldrsp16 r4, sp, 34 # 2-byte Folded Reload
; CHECK-NEXT:    mov16 r2, r4
; CHECK-NEXT:    ldrsp16 r3, sp, 32 # 2-byte Folded Reload
; CHECK-NEXT:    call lotsOfArgs2
; CHECK-NEXT:    ldrsp16 r0, sp, 26 # 2-byte Folded Reload
; CHECK-NEXT:    addi16 r0, r5, r0
; CHECK-NEXT:    addi16 r0, r4, r0
; CHECK-NEXT:    addi16 r1, r0, r1
; CHECK-NEXT:    ldrsp16 r0, sp, 38 # 2-byte Folded Reload
; CHECK-NEXT:    ldrsp32 d3, sp, 40 # 4-byte Folded Reload
; CHECK-NEXT:    ldrsp32 d2, sp, 44 # 4-byte Folded Reload
; CHECK-NEXT:    addsp sp, sp, 48
; CHECK-NEXT:    ret
  %tmp = call i16 @lotsOfArgs2(i16 %a1, i16 %a2, i16 %a3, i16 %a4, i16 %a5, i16 %a6, i16 %a7, i16 %a8, i16 %a9, i16 %a10, i16 %a11)
  %tmp0 = call i16 @lotsOfArgs2(i16 %a11, i16 %a10, i16 %a9, i16 %a8, i16 %a7, i16 %a6, i16 %a5, i16 %a4, i16 %a3, i16 %a2, i16 %a1)
  %tmp1 = add i16 %a1, %tmp
  %tmp2 = add i16 %a10, %tmp1
  %res = add i16 %tmp2, %tmp0
  ret i16 %res
}
