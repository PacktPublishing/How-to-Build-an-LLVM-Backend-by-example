//===-- H2BLBISelDAGToDAG.cpp - A dag to dag inst selector for H2BLB ------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines a DAG pattern matching instruction selector for H2BLB,
// converting from a legalized dag to a H2BLB dag.
//
//===----------------------------------------------------------------------===//

#include "H2BLB.h"
#include "H2BLBTargetMachine.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Support/Debug.h"
#include "llvm/Target/TargetMachine.h"

using namespace llvm;

#define DEBUG_TYPE "h2blb-isel"
#define PASS_NAME "H2BLB DAG->DAG Pattern Instruction Selection"

namespace {

// H2BLB SDISel implementation.
class H2BLBDAGToDAGISel : public SelectionDAGISel {
public:
  explicit H2BLBDAGToDAGISel(TargetMachine &TM) : SelectionDAGISel(TM) {}

private:
  void Select(SDNode *N) override;

  // Method for the complex pattern matching addressing modes.
  bool selectAddrMode(SDValue N, SDValue &Base, SDValue &OffImm);

  // Method for the complex pattern matching of sp-based addressing modes.
  bool selectSPAddrMode(SDValue N, SDValue &SP, SDValue &OffImm);
// Include the pieces autogenerated from the target description.
#include "H2BLBGenDAGISel.inc"
};

// Pass for the legacy pass manager.
class H2BLBDAGToDAGISelLegacy : public SelectionDAGISelLegacy {
public:
  static char ID;
  H2BLBDAGToDAGISelLegacy(H2BLBTargetMachine &TM)
      : SelectionDAGISelLegacy(ID, std::make_unique<H2BLBDAGToDAGISel>(TM)) {}
};
} // namespace

void H2BLBDAGToDAGISel::Select(SDNode *N) {
  // If the node is already selected, there is nothing to do.
  if (N->isMachineOpcode()) {
    LLVM_DEBUG(dbgs() << "Skip: ");
    LLVM_DEBUG(N->print(dbgs(), CurDAG));
    LLVM_DEBUG(dbgs() << '\n');
    return;
  }

  SelectCode(N);
}

bool H2BLBDAGToDAGISel::selectAddrMode(SDValue N, SDValue &Base,
                                       SDValue &OffImm) {
  SDLoc dl(N);
  // Loads and stores through the stack need to go through the SP-based
  // addressing mode.
  if (N.getOpcode() == ISD::FrameIndex)
    return false;

  // Do some matching of ADD + immediate and fold if it fits.
  Base = N;
  uint64_t Offset = 0;
  if (N->getOpcode() == ISD::ADD && isa<ConstantSDNode>(N->getOperand(1))) {
    uint64_t CstImm = N->getConstantOperandVal(1);
    if (CstImm < 16) {
      Base = N->getOperand(0);
      Offset = CstImm;
    }
  }

  // Base only.
  OffImm = CurDAG->getTargetConstant(Offset, dl, MVT::i16);
  return true;
}

bool H2BLBDAGToDAGISel::selectSPAddrMode(SDValue N, SDValue &Base,
                                         SDValue &OffImm) {
  SDLoc dl(N);
  const DataLayout &DL = CurDAG->getDataLayout();
  const TargetLowering *TLI = getTargetLowering();
  if (N.getOpcode() == ISD::FrameIndex) {
    int FI = cast<FrameIndexSDNode>(N)->getIndex();
    Base = CurDAG->getTargetFrameIndex(FI, TLI->getPointerTy(DL));
    OffImm = CurDAG->getTargetConstant(0, dl, MVT::i16);
    return true;
  }

  auto MaybeSPNode = [](SDValue N) -> SDValue {
    if (N.getOpcode() == ISD::CopyFromReg) {
      Register Reg = cast<RegisterSDNode>(N.getOperand(1))->getReg();
      if (Reg == H2BLB::SP)
        return N.getOperand(1);
    }
    return SDValue();
  };

  if ((Base = MaybeSPNode(N)) != SDValue()) {
    OffImm = CurDAG->getTargetConstant(0, dl, MVT::i16);
    return true;
  }

  // Do some matching of ADD + immediate and fold if it fits.
  if (N->getOpcode() != ISD::ADD)
    return false;
  Base = MaybeSPNode(N->getOperand(0));
  if (Base == SDValue())
    return false;
  if (!isa<ConstantSDNode>(N->getOperand(1)))
    return false;
  int64_t CstImm = N->getConstantOperandVal(1);
  if (CstImm < -64 || CstImm >= 64)
    return false;

  OffImm = CurDAG->getTargetConstant(CstImm, dl, MVT::i16);
  return true;
}

char H2BLBDAGToDAGISelLegacy::ID = 0;

INITIALIZE_PASS(H2BLBDAGToDAGISelLegacy, DEBUG_TYPE, "H2BLB ISel DAG->DAG",
                false, false)

Pass *llvm::createH2BLBISelDAG(H2BLBTargetMachine &TM) {
  return new H2BLBDAGToDAGISelLegacy(TM);
}
