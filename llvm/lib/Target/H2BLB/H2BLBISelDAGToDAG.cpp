//===-- H2BLBISelDAGToDAG.cpp - A dag to dag inst selector for H2BLB ------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines a DAG pattern matching instruction selector for H2BLB,
// converting from a legalized dag to a H2BLB dag.
//
//===----------------------------------------------------------------------===//

#include "H2BLB.h"
#include "H2BLBTargetMachine.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Support/Debug.h"
#include "llvm/Target/TargetMachine.h"

using namespace llvm;

#define DEBUG_TYPE "h2blb-isel"
#define PASS_NAME "H2BLB DAG->DAG Pattern Instruction Selection"

namespace {

// H2BLB SDISel implementation.
class H2BLBDAGToDAGISel : public SelectionDAGISel {
public:
  explicit H2BLBDAGToDAGISel(TargetMachine &TM) : SelectionDAGISel(TM) {}

private:
  void Select(SDNode *N) override;

  // Method for the complex pattern matching addressing modes.
  bool selectAddrMode(SDValue N, SDValue &Base, SDValue &OffImm);

  // Method for the complex pattern matching of sp-based addressing modes.
  bool selectSPAddrMode(SDValue N, SDValue &SP, SDValue &OffImm);
// Include the pieces autogenerated from the target description.
#include "H2BLBGenDAGISel.inc"
};

// Pass for the legacy pass manager.
class H2BLBDAGToDAGISelLegacy : public SelectionDAGISelLegacy {
public:
  static char ID;
  H2BLBDAGToDAGISelLegacy(H2BLBTargetMachine &TM)
      : SelectionDAGISelLegacy(ID, std::make_unique<H2BLBDAGToDAGISel>(TM)) {}
};
} // namespace

void H2BLBDAGToDAGISel::Select(SDNode *N) {
  // If the node is already selected, there is nothing to do.
  if (N->isMachineOpcode()) {
    LLVM_DEBUG(dbgs() << "Skip: ");
    LLVM_DEBUG(N->print(dbgs(), CurDAG));
    LLVM_DEBUG(dbgs() << '\n');
    return;
  }

  SelectCode(N);
}

bool H2BLBDAGToDAGISel::selectAddrMode(SDValue N, SDValue &Base,
                                       SDValue &OffImm) {
  SDLoc dl(N);
  // Loads and stores through the stack need to go through the SP-based
  // addressing mode.
  if (N.getOpcode() == ISD::FrameIndex)
    return false;

  // Do some matching of ADD + immediate and fold if it fits.
  Base = N;
  uint64_t Offset = 0;
  if (N->getOpcode() == ISD::ADD && isa<ConstantSDNode>(N->getOperand(1))) {
    uint64_t CstImm = N->getConstantOperandVal(1);
    if (CstImm < 16) {
      Base = N->getOperand(0);
      Offset = CstImm;
    }
  }

  // Base only.
  OffImm = CurDAG->getTargetConstant(Offset, dl, MVT::i16);
  return true;
}

bool H2BLBDAGToDAGISel::selectSPAddrMode(SDValue N, SDValue &Base,
                                         SDValue &OffImm) {
  SDLoc dl(N);
  const DataLayout &DL = CurDAG->getDataLayout();
  const TargetLowering *TLI = getTargetLowering();

  auto MaybeSPNode = [](SDValue N) -> bool {
    if (N.getOpcode() == ISD::CopyFromReg) {
      Register Reg = cast<RegisterSDNode>(N.getOperand(1))->getReg();
      return Reg == H2BLB::SP;
    }
    return false;
  };

  auto MaybeFrameIndex = [&](SDValue N) -> SDValue {
    if (N.getOpcode() == ISD::FrameIndex) {
      int FI = cast<FrameIndexSDNode>(N)->getIndex();
      return CurDAG->getTargetFrameIndex(FI, TLI->getPointerTy(DL));
    }
    return SDValue();
  };

  auto MatchSPRegOrIndex = [&](SDValue N, SDValue &MaybeIndex) -> bool {
    MaybeIndex = MaybeFrameIndex(N);
    if (MaybeIndex != SDValue())
      return true;
    return MaybeSPNode(N);
  };

  // On a match, if MaybeIndex is not a SDValue we are dealing with a
  // FrameIndex, otherwise we are dealing with SP.
  SDValue MaybeIndex;
  bool Matched = false;
  int64_t CstImm = 0;

  switch (N->getOpcode()) {
  case ISD::CopyFromReg:
  case ISD::FrameIndex:
    Matched = MatchSPRegOrIndex(N, MaybeIndex);
    break;
  case ISD::OR:
  case ISD::ADD: {
    // Do some matching of ADD + immediate and fold if it fits.
    if (!isa<ConstantSDNode>(N->getOperand(1)))
      return false;
    CstImm = N->getConstantOperandVal(1);
    if (CstImm < -64 || CstImm >= 64)
      return false;

    Matched = MatchSPRegOrIndex(N->getOperand(0), MaybeIndex);
    break;
  }
  default:
    Matched = false;
    break;
  }

  if (!Matched)
    return false;

  if (MaybeIndex)
    Base = MaybeIndex;
  else
    Base = CurDAG->getRegister(H2BLB::SP, MVT::i16);
  OffImm = CurDAG->getTargetConstant(CstImm, dl, MVT::i16);
  return true;
}

char H2BLBDAGToDAGISelLegacy::ID = 0;

INITIALIZE_PASS(H2BLBDAGToDAGISelLegacy, DEBUG_TYPE, "H2BLB ISel DAG->DAG",
                false, false)

Pass *llvm::createH2BLBISelDAG(H2BLBTargetMachine &TM) {
  return new H2BLBDAGToDAGISelLegacy(TM);
}
