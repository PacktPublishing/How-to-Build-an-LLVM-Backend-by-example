; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
; RUN: llc  -o - %s -global-isel -global-isel-abort=1 --stop-after=irtranslator | FileCheck %s
target triple="h2blb--"

define void @empty() {
  ; CHECK-LABEL: name: empty
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   RETURN implicit $r0
  ret void
}

; Check that we directly select the non-pseudo instruction
; when the immediate is in the [0,127] range.
define i16 @retCstInRange() {
  ; CHECK-LABEL: name: retCstInRange
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s16) = G_CONSTANT i16 11
  ; CHECK-NEXT:   $r1 = COPY [[C]](s16)
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1
  ret i16 11
}

; Check that we select the pseudo instruction for out-of-range
; constants. The pseudo instruction will need to be fixed
; eventually.
define i16 @retCst() {
  ; CHECK-LABEL: name: retCst
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s16) = G_CONSTANT i16 132
  ; CHECK-NEXT:   $r1 = COPY [[C]](s16)
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1
  ret i16 132
}

define i16 @oneArgi16(i16 %arg) {
  ; CHECK-LABEL: name: oneArgi16
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s16) = COPY $r1
  ; CHECK-NEXT:   $r1 = COPY [[COPY]](s16)
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1
  ret i16 %arg
}

define half @oneArgHalf(half %arg) {
  ; CHECK-LABEL: name: oneArgHalf
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s16) = COPY $r1
  ; CHECK-NEXT:   $r1 = COPY [[COPY]](s16)
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1
  ret half %arg
}

define i32 @oneArgi32(i32 %arg) {
  ; CHECK-LABEL: name: oneArgi32
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $d1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $d1
  ; CHECK-NEXT:   $d1 = COPY [[COPY]](s32)
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $d1
  ret i32 %arg
}

define <2 x i16> @oneArgv2i16(<2 x i16> %arg) {
  ; CHECK-LABEL: name: oneArgv2i16
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s16) = COPY $r1
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s16) = COPY $r2
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<2 x s16>) = G_BUILD_VECTOR [[COPY]](s16), [[COPY1]](s16)
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(s16), [[UV1:%[0-9]+]]:_(s16) = G_UNMERGE_VALUES [[BUILD_VECTOR]](<2 x s16>)
  ; CHECK-NEXT:   $r1 = COPY [[UV]](s16)
  ; CHECK-NEXT:   $r2 = COPY [[UV1]](s16)
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1, implicit $r2
  ret <2 x i16> %arg
}

define <2 x i16> @twoArgsi16(i16 %arg, i16 %arg1) {
  ; CHECK-LABEL: name: twoArgsi16
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s16) = COPY $r1
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s16) = COPY $r2
  ; CHECK-NEXT:   [[DEF:%[0-9]+]]:_(<2 x s16>) = G_IMPLICIT_DEF
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s16) = G_CONSTANT i16 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s16) = G_CONSTANT i16 1
  ; CHECK-NEXT:   [[IVEC:%[0-9]+]]:_(<2 x s16>) = G_INSERT_VECTOR_ELT [[DEF]], [[COPY]](s16), [[C]](s16)
  ; CHECK-NEXT:   [[IVEC1:%[0-9]+]]:_(<2 x s16>) = G_INSERT_VECTOR_ELT [[IVEC]], [[COPY1]](s16), [[C1]](s16)
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(s16), [[UV1:%[0-9]+]]:_(s16) = G_UNMERGE_VALUES [[IVEC1]](<2 x s16>)
  ; CHECK-NEXT:   $r1 = COPY [[UV]](s16)
  ; CHECK-NEXT:   $r2 = COPY [[UV1]](s16)
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1, implicit $r2
  %partial = insertelement <2 x i16> poison, i16 %arg, i32 0
  %res = insertelement <2 x i16> %partial, i16 %arg1, i32 1
  ret <2 x i16> %res
}

; The fourth i16 argument is expected to be passed through a stack slot.
define i16 @fourArgsi16(i16 %arg, i16 %arg1, i16 %arg2, i16 %arg3) {
  ; CHECK-LABEL: name: fourArgsi16
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r2, $r3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s16) = COPY $r1
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s16) = COPY $r2
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(s16) = COPY $r3
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s16) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (s16) from %fixed-stack.0, align 8)
  ; CHECK-NEXT:   $r1 = COPY [[LOAD]](s16)
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1
  ret i16 %arg3
}

; Check that we properly set r1 as the input argument for the call.
define i16 @callAFctWithOneArg(i16 %arg) {
  ; CHECK-LABEL: name: callAFctWithOneArg
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s16) = COPY $r1
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   $r1 = COPY [[COPY]](s16)
  ; CHECK-NEXT:   CALL @oneArgi16, csr, implicit-def $r0, implicit $sp, implicit $r1, implicit-def $r1
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s16) = COPY $r1
  ; CHECK-NEXT:   $r1 = COPY [[COPY1]](s16)
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1
  %res = call i16 @oneArgi16(i16 %arg)
  ret i16 %res
}

declare i16 @arg16_32(i16, i32)

; Check that we set r1 and d1 as the input argument for the call.
define i16 @callAFctWithArg16_32(i16 %arg, i32 %arg1) {
  ; CHECK-LABEL: name: callAFctWithArg16_32
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $d1, $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s16) = COPY $r1
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $d1
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   $r1 = COPY [[COPY]](s16)
  ; CHECK-NEXT:   $d1 = COPY [[COPY1]](s32)
  ; CHECK-NEXT:   CALL @arg16_32, csr, implicit-def $r0, implicit $sp, implicit $r1, implicit $d1, implicit-def $r1
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(s16) = COPY $r1
  ; CHECK-NEXT:   $r1 = COPY [[COPY2]](s16)
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1
  %res = call i16 @arg16_32(i16 %arg, i32 %arg1)
  ret i16 %res
}

declare i16 @arg16_16(i16, i16)

; Check that we swap the input arg r1, r2 to r2, r1 to match the
; desired argument sequence.
define i16 @callAFctWithTwoI16Arg(i16 %arg, i16 %arg1) {
  ; CHECK-LABEL: name: callAFctWithTwoI16Arg
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s16) = COPY $r1
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s16) = COPY $r2
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   $r1 = COPY [[COPY1]](s16)
  ; CHECK-NEXT:   $r2 = COPY [[COPY]](s16)
  ; CHECK-NEXT:   CALL @arg16_16, csr, implicit-def $r0, implicit $sp, implicit $r1, implicit $r2, implicit-def $r1
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(s16) = COPY $r1
  ; CHECK-NEXT:   $r1 = COPY [[COPY2]](s16)
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1
  %res = call i16 @arg16_16(i16 %arg1, i16 %arg)
  ret i16 %res
}

declare i16 @lotsOfArgs2(i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16)

; Check that we duplicate %arg on as many stack slots as
; required to call lotsOfArgs1.
define i16 @foo1(i16 %arg) {
  ; CHECK-LABEL: name: foo1
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s16) = COPY $r1
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 16, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s16) = G_CONSTANT i16 0
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY1]], [[C]](s16)
  ; CHECK-NEXT:   G_STORE [[COPY]](s16), [[PTR_ADD]](p0) :: (store (s16) into stack, align 1)
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s16) = G_CONSTANT i16 2
  ; CHECK-NEXT:   [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY1]], [[C1]](s16)
  ; CHECK-NEXT:   G_STORE [[COPY]](s16), [[PTR_ADD1]](p0) :: (store (s16) into stack + 2, align 1)
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s16) = G_CONSTANT i16 4
  ; CHECK-NEXT:   [[PTR_ADD2:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY1]], [[C2]](s16)
  ; CHECK-NEXT:   G_STORE [[COPY]](s16), [[PTR_ADD2]](p0) :: (store (s16) into stack + 4, align 1)
  ; CHECK-NEXT:   [[C3:%[0-9]+]]:_(s16) = G_CONSTANT i16 6
  ; CHECK-NEXT:   [[PTR_ADD3:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY1]], [[C3]](s16)
  ; CHECK-NEXT:   G_STORE [[COPY]](s16), [[PTR_ADD3]](p0) :: (store (s16) into stack + 6, align 1)
  ; CHECK-NEXT:   [[C4:%[0-9]+]]:_(s16) = G_CONSTANT i16 8
  ; CHECK-NEXT:   [[PTR_ADD4:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY1]], [[C4]](s16)
  ; CHECK-NEXT:   G_STORE [[COPY]](s16), [[PTR_ADD4]](p0) :: (store (s16) into stack + 8, align 1)
  ; CHECK-NEXT:   [[C5:%[0-9]+]]:_(s16) = G_CONSTANT i16 10
  ; CHECK-NEXT:   [[PTR_ADD5:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY1]], [[C5]](s16)
  ; CHECK-NEXT:   G_STORE [[COPY]](s16), [[PTR_ADD5]](p0) :: (store (s16) into stack + 10, align 1)
  ; CHECK-NEXT:   [[C6:%[0-9]+]]:_(s16) = G_CONSTANT i16 12
  ; CHECK-NEXT:   [[PTR_ADD6:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY1]], [[C6]](s16)
  ; CHECK-NEXT:   G_STORE [[COPY]](s16), [[PTR_ADD6]](p0) :: (store (s16) into stack + 12, align 1)
  ; CHECK-NEXT:   [[C7:%[0-9]+]]:_(s16) = G_CONSTANT i16 14
  ; CHECK-NEXT:   [[PTR_ADD7:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY1]], [[C7]](s16)
  ; CHECK-NEXT:   G_STORE [[COPY]](s16), [[PTR_ADD7]](p0) :: (store (s16) into stack + 14, align 1)
  ; CHECK-NEXT:   $r1 = COPY [[COPY]](s16)
  ; CHECK-NEXT:   $r2 = COPY [[COPY]](s16)
  ; CHECK-NEXT:   $r3 = COPY [[COPY]](s16)
  ; CHECK-NEXT:   CALL @lotsOfArgs1, csr, implicit-def $r0, implicit $sp, implicit $r1, implicit $r2, implicit $r3, implicit-def $r1
  ; CHECK-NEXT:   ADJCALLSTACKUP 16, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(s16) = COPY $r1
  ; CHECK-NEXT:   $r1 = COPY [[COPY2]](s16)
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1
   %res = call i16 @lotsOfArgs1(i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg, i16 %arg)
   ret i16 %res
}

; Stress test for the stack lowering.
define i16 @lotsOfArgs1(i16 %a1, i16 %a2, i16 %a3, i16 %a4, i16 %a5, i16 %a6, i16 %a7, i16 %a8, i16 %a9, i16 %a10, i16 %a11) {
  ; CHECK-LABEL: name: lotsOfArgs1
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r2, $r3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s16) = COPY $r1
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s16) = COPY $r2
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(s16) = COPY $r3
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.7
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s16) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (s16) from %fixed-stack.7, align 8)
  ; CHECK-NEXT:   [[FRAME_INDEX1:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.6
  ; CHECK-NEXT:   [[LOAD1:%[0-9]+]]:_(s16) = G_LOAD [[FRAME_INDEX1]](p0) :: (invariant load (s16) from %fixed-stack.6)
  ; CHECK-NEXT:   [[FRAME_INDEX2:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.5
  ; CHECK-NEXT:   [[LOAD2:%[0-9]+]]:_(s16) = G_LOAD [[FRAME_INDEX2]](p0) :: (invariant load (s16) from %fixed-stack.5, align 4)
  ; CHECK-NEXT:   [[FRAME_INDEX3:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.4
  ; CHECK-NEXT:   [[LOAD3:%[0-9]+]]:_(s16) = G_LOAD [[FRAME_INDEX3]](p0) :: (invariant load (s16) from %fixed-stack.4)
  ; CHECK-NEXT:   [[FRAME_INDEX4:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.3
  ; CHECK-NEXT:   [[LOAD4:%[0-9]+]]:_(s16) = G_LOAD [[FRAME_INDEX4]](p0) :: (invariant load (s16) from %fixed-stack.3, align 8)
  ; CHECK-NEXT:   [[FRAME_INDEX5:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.2
  ; CHECK-NEXT:   [[LOAD5:%[0-9]+]]:_(s16) = G_LOAD [[FRAME_INDEX5]](p0) :: (invariant load (s16) from %fixed-stack.2)
  ; CHECK-NEXT:   [[FRAME_INDEX6:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.1
  ; CHECK-NEXT:   [[LOAD6:%[0-9]+]]:_(s16) = G_LOAD [[FRAME_INDEX6]](p0) :: (invariant load (s16) from %fixed-stack.1, align 4)
  ; CHECK-NEXT:   [[FRAME_INDEX7:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD7:%[0-9]+]]:_(s16) = G_LOAD [[FRAME_INDEX7]](p0) :: (invariant load (s16) from %fixed-stack.0)
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 16, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s16) = G_CONSTANT i16 0
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY3]], [[C]](s16)
  ; CHECK-NEXT:   G_STORE [[LOAD]](s16), [[PTR_ADD]](p0) :: (store (s16) into stack, align 1)
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s16) = G_CONSTANT i16 2
  ; CHECK-NEXT:   [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY3]], [[C1]](s16)
  ; CHECK-NEXT:   G_STORE [[LOAD1]](s16), [[PTR_ADD1]](p0) :: (store (s16) into stack + 2, align 1)
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s16) = G_CONSTANT i16 4
  ; CHECK-NEXT:   [[PTR_ADD2:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY3]], [[C2]](s16)
  ; CHECK-NEXT:   G_STORE [[LOAD2]](s16), [[PTR_ADD2]](p0) :: (store (s16) into stack + 4, align 1)
  ; CHECK-NEXT:   [[C3:%[0-9]+]]:_(s16) = G_CONSTANT i16 6
  ; CHECK-NEXT:   [[PTR_ADD3:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY3]], [[C3]](s16)
  ; CHECK-NEXT:   G_STORE [[LOAD3]](s16), [[PTR_ADD3]](p0) :: (store (s16) into stack + 6, align 1)
  ; CHECK-NEXT:   [[C4:%[0-9]+]]:_(s16) = G_CONSTANT i16 8
  ; CHECK-NEXT:   [[PTR_ADD4:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY3]], [[C4]](s16)
  ; CHECK-NEXT:   G_STORE [[LOAD4]](s16), [[PTR_ADD4]](p0) :: (store (s16) into stack + 8, align 1)
  ; CHECK-NEXT:   [[C5:%[0-9]+]]:_(s16) = G_CONSTANT i16 10
  ; CHECK-NEXT:   [[PTR_ADD5:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY3]], [[C5]](s16)
  ; CHECK-NEXT:   G_STORE [[LOAD5]](s16), [[PTR_ADD5]](p0) :: (store (s16) into stack + 10, align 1)
  ; CHECK-NEXT:   [[C6:%[0-9]+]]:_(s16) = G_CONSTANT i16 12
  ; CHECK-NEXT:   [[PTR_ADD6:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY3]], [[C6]](s16)
  ; CHECK-NEXT:   G_STORE [[LOAD6]](s16), [[PTR_ADD6]](p0) :: (store (s16) into stack + 12, align 1)
  ; CHECK-NEXT:   [[C7:%[0-9]+]]:_(s16) = G_CONSTANT i16 14
  ; CHECK-NEXT:   [[PTR_ADD7:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY3]], [[C7]](s16)
  ; CHECK-NEXT:   G_STORE [[LOAD7]](s16), [[PTR_ADD7]](p0) :: (store (s16) into stack + 14, align 1)
  ; CHECK-NEXT:   $r1 = COPY [[COPY]](s16)
  ; CHECK-NEXT:   $r2 = COPY [[COPY1]](s16)
  ; CHECK-NEXT:   $r3 = COPY [[COPY2]](s16)
  ; CHECK-NEXT:   CALL @lotsOfArgs2, csr, implicit-def $r0, implicit $sp, implicit $r1, implicit $r2, implicit $r3, implicit-def $r1
  ; CHECK-NEXT:   ADJCALLSTACKUP 16, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:_(s16) = COPY $r1
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 16, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C8:%[0-9]+]]:_(s16) = G_CONSTANT i16 0
  ; CHECK-NEXT:   [[PTR_ADD8:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY5]], [[C8]](s16)
  ; CHECK-NEXT:   G_STORE [[LOAD4]](s16), [[PTR_ADD8]](p0) :: (store (s16) into stack, align 1)
  ; CHECK-NEXT:   [[C9:%[0-9]+]]:_(s16) = G_CONSTANT i16 2
  ; CHECK-NEXT:   [[PTR_ADD9:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY5]], [[C9]](s16)
  ; CHECK-NEXT:   G_STORE [[LOAD3]](s16), [[PTR_ADD9]](p0) :: (store (s16) into stack + 2, align 1)
  ; CHECK-NEXT:   [[C10:%[0-9]+]]:_(s16) = G_CONSTANT i16 4
  ; CHECK-NEXT:   [[PTR_ADD10:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY5]], [[C10]](s16)
  ; CHECK-NEXT:   G_STORE [[LOAD2]](s16), [[PTR_ADD10]](p0) :: (store (s16) into stack + 4, align 1)
  ; CHECK-NEXT:   [[C11:%[0-9]+]]:_(s16) = G_CONSTANT i16 6
  ; CHECK-NEXT:   [[PTR_ADD11:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY5]], [[C11]](s16)
  ; CHECK-NEXT:   G_STORE [[LOAD1]](s16), [[PTR_ADD11]](p0) :: (store (s16) into stack + 6, align 1)
  ; CHECK-NEXT:   [[C12:%[0-9]+]]:_(s16) = G_CONSTANT i16 8
  ; CHECK-NEXT:   [[PTR_ADD12:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY5]], [[C12]](s16)
  ; CHECK-NEXT:   G_STORE [[LOAD]](s16), [[PTR_ADD12]](p0) :: (store (s16) into stack + 8, align 1)
  ; CHECK-NEXT:   [[C13:%[0-9]+]]:_(s16) = G_CONSTANT i16 10
  ; CHECK-NEXT:   [[PTR_ADD13:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY5]], [[C13]](s16)
  ; CHECK-NEXT:   G_STORE [[COPY2]](s16), [[PTR_ADD13]](p0) :: (store (s16) into stack + 10, align 1)
  ; CHECK-NEXT:   [[C14:%[0-9]+]]:_(s16) = G_CONSTANT i16 12
  ; CHECK-NEXT:   [[PTR_ADD14:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY5]], [[C14]](s16)
  ; CHECK-NEXT:   G_STORE [[COPY1]](s16), [[PTR_ADD14]](p0) :: (store (s16) into stack + 12, align 1)
  ; CHECK-NEXT:   [[C15:%[0-9]+]]:_(s16) = G_CONSTANT i16 14
  ; CHECK-NEXT:   [[PTR_ADD15:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY5]], [[C15]](s16)
  ; CHECK-NEXT:   G_STORE [[COPY]](s16), [[PTR_ADD15]](p0) :: (store (s16) into stack + 14, align 1)
  ; CHECK-NEXT:   $r1 = COPY [[LOAD7]](s16)
  ; CHECK-NEXT:   $r2 = COPY [[LOAD6]](s16)
  ; CHECK-NEXT:   $r3 = COPY [[LOAD5]](s16)
  ; CHECK-NEXT:   CALL @lotsOfArgs2, csr, implicit-def $r0, implicit $sp, implicit $r1, implicit $r2, implicit $r3, implicit-def $r1
  ; CHECK-NEXT:   ADJCALLSTACKUP 16, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY6:%[0-9]+]]:_(s16) = COPY $r1
  ; CHECK-NEXT:   [[ADD:%[0-9]+]]:_(s16) = G_ADD [[COPY]], [[COPY4]]
  ; CHECK-NEXT:   [[ADD1:%[0-9]+]]:_(s16) = G_ADD [[LOAD6]], [[ADD]]
  ; CHECK-NEXT:   [[ADD2:%[0-9]+]]:_(s16) = G_ADD [[ADD1]], [[COPY6]]
  ; CHECK-NEXT:   $r1 = COPY [[ADD2]](s16)
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $r1
  %tmp = call i16 @lotsOfArgs2(i16 %a1, i16 %a2, i16 %a3, i16 %a4, i16 %a5, i16 %a6, i16 %a7, i16 %a8, i16 %a9, i16 %a10, i16 %a11)
  %tmp0 = call i16 @lotsOfArgs2(i16 %a11, i16 %a10, i16 %a9, i16 %a8, i16 %a7, i16 %a6, i16 %a5, i16 %a4, i16 %a3, i16 %a2, i16 %a1)
  %tmp1 = add i16 %a1, %tmp
  %tmp2 = add i16 %a10, %tmp1
  %res = add i16 %tmp2, %tmp0
  ret i16 %res
}

; Lowering of structures.

%struct.nested = type { i8, { i8, i32 }, i32}

define i32 @structInputArg(%struct.nested %struct) {
  ; CHECK-LABEL: name: structInputArg
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s16) = COPY $r1
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(s8) = G_TRUNC [[COPY]](s16)
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s16) = COPY $r2
  ; CHECK-NEXT:   [[TRUNC1:%[0-9]+]]:_(s8) = G_TRUNC [[COPY1]](s16)
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.1
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s32) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (s32) from %fixed-stack.1, align 8)
  ; CHECK-NEXT:   [[FRAME_INDEX1:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD1:%[0-9]+]]:_(s32) = G_LOAD [[FRAME_INDEX1]](p0) :: (invariant load (s32) from %fixed-stack.0, align 2)
  ; CHECK-NEXT:   $d1 = COPY [[LOAD]](s32)
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $d1
  %res = extractvalue %struct.nested %struct, 1, 1
  ret i32 %res
}

define i32 @structOutArg() {
  ; CHECK-LABEL: name: structOutArg
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %stack.0.addr_input
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s8) = G_LOAD [[FRAME_INDEX]](p0) :: (dereferenceable load (s8) from %ir.addr_input, align 4)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s16) = G_CONSTANT i16 4
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[FRAME_INDEX]], [[C]](s16)
  ; CHECK-NEXT:   [[LOAD1:%[0-9]+]]:_(s8) = G_LOAD [[PTR_ADD]](p0) :: (dereferenceable load (s8) from %ir.addr_input + 4, align 4)
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s16) = G_CONSTANT i16 8
  ; CHECK-NEXT:   [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[FRAME_INDEX]], [[C1]](s16)
  ; CHECK-NEXT:   [[LOAD2:%[0-9]+]]:_(s32) = G_LOAD [[PTR_ADD1]](p0) :: (dereferenceable load (s32) from %ir.addr_input + 8)
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s16) = G_CONSTANT i16 12
  ; CHECK-NEXT:   [[PTR_ADD2:%[0-9]+]]:_(p0) = G_PTR_ADD [[FRAME_INDEX]], [[C2]](s16)
  ; CHECK-NEXT:   [[LOAD3:%[0-9]+]]:_(s32) = G_LOAD [[PTR_ADD2]](p0) :: (dereferenceable load (s32) from %ir.addr_input + 12)
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(s16) = G_ANYEXT [[LOAD]](s8)
  ; CHECK-NEXT:   [[ANYEXT1:%[0-9]+]]:_(s16) = G_ANYEXT [[LOAD1]](s8)
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $sp
  ; CHECK-NEXT:   [[C3:%[0-9]+]]:_(s16) = G_CONSTANT i16 0
  ; CHECK-NEXT:   [[PTR_ADD3:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C3]](s16)
  ; CHECK-NEXT:   G_STORE [[LOAD2]](s32), [[PTR_ADD3]](p0) :: (store (s32) into stack, align 1)
  ; CHECK-NEXT:   [[C4:%[0-9]+]]:_(s16) = G_CONSTANT i16 2
  ; CHECK-NEXT:   [[PTR_ADD4:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C4]](s16)
  ; CHECK-NEXT:   G_STORE [[LOAD3]](s32), [[PTR_ADD4]](p0) :: (store (s32) into stack + 2, align 1)
  ; CHECK-NEXT:   $r1 = COPY [[ANYEXT]](s16)
  ; CHECK-NEXT:   $r2 = COPY [[ANYEXT1]](s16)
  ; CHECK-NEXT:   CALL @structInputArg, csr, implicit-def $r0, implicit $sp, implicit $r1, implicit $r2, implicit-def $d1
  ; CHECK-NEXT:   ADJCALLSTACKUP 4, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s32) = COPY $d1
  ; CHECK-NEXT:   $d1 = COPY [[COPY1]](s32)
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $d1
  %addr_input = alloca %struct.nested
  %input = load %struct.nested, ptr %addr_input
  %res = call i32 @structInputArg(%struct.nested %input)
  ret i32 %res
}

define %struct.nested @structReturn() {
  ; CHECK-LABEL: name: structReturn
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(p0) = COPY $r1
  ; CHECK-NEXT:   [[DEF:%[0-9]+]]:_(s8) = G_IMPLICIT_DEF
  ; CHECK-NEXT:   [[DEF1:%[0-9]+]]:_(s32) = G_IMPLICIT_DEF
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s8) = G_CONSTANT i8 0
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s8) = G_CONSTANT i8 1
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 2
  ; CHECK-NEXT:   [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK-NEXT:   G_STORE [[C]](s8), [[COPY]](p0) :: (store (s8), align 8)
  ; CHECK-NEXT:   [[C4:%[0-9]+]]:_(s16) = G_CONSTANT i16 4
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C4]](s16)
  ; CHECK-NEXT:   G_STORE [[C1]](s8), [[PTR_ADD]](p0) :: (store (s8), align 4)
  ; CHECK-NEXT:   [[C5:%[0-9]+]]:_(s16) = G_CONSTANT i16 8
  ; CHECK-NEXT:   [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C5]](s16)
  ; CHECK-NEXT:   G_STORE [[C2]](s32), [[PTR_ADD1]](p0) :: (store (s32), align 8)
  ; CHECK-NEXT:   [[C6:%[0-9]+]]:_(s16) = G_CONSTANT i16 12
  ; CHECK-NEXT:   [[PTR_ADD2:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C6]](s16)
  ; CHECK-NEXT:   G_STORE [[C3]](s32), [[PTR_ADD2]](p0) :: (store (s32))
  ; CHECK-NEXT:   RETURN implicit $r0
  %struct1 = insertvalue %struct.nested undef, i8 0, 0
  %struct2 = insertvalue %struct.nested %struct1, i8 1, 1, 0
  %struct3 = insertvalue %struct.nested %struct2, i32 2, 1, 1
  %struct4 = insertvalue %struct.nested %struct3, i32 3, 2
  ret %struct.nested %struct4
}

define i32 @readStructReturn() {
  ; CHECK-LABEL: name: readStructReturn
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %stack.0
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   $r1 = COPY [[FRAME_INDEX]](p0)
  ; CHECK-NEXT:   CALL @structReturn, csr, implicit-def $r0, implicit $sp, implicit $r1
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(s8) = G_LOAD [[FRAME_INDEX]](p0) :: (load (s8) from %stack.0, align 8)
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(s16) = G_CONSTANT i16 4
  ; CHECK-NEXT:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[FRAME_INDEX]], [[C]](s16)
  ; CHECK-NEXT:   [[LOAD1:%[0-9]+]]:_(s8) = G_LOAD [[PTR_ADD]](p0) :: (load (s8) from %stack.0, align 4)
  ; CHECK-NEXT:   [[C1:%[0-9]+]]:_(s16) = G_CONSTANT i16 8
  ; CHECK-NEXT:   [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[FRAME_INDEX]], [[C1]](s16)
  ; CHECK-NEXT:   [[LOAD2:%[0-9]+]]:_(s32) = G_LOAD [[PTR_ADD1]](p0) :: (load (s32) from %stack.0, align 8)
  ; CHECK-NEXT:   [[C2:%[0-9]+]]:_(s16) = G_CONSTANT i16 12
  ; CHECK-NEXT:   [[PTR_ADD2:%[0-9]+]]:_(p0) = G_PTR_ADD [[FRAME_INDEX]], [[C2]](s16)
  ; CHECK-NEXT:   [[LOAD3:%[0-9]+]]:_(s32) = G_LOAD [[PTR_ADD2]](p0) :: (load (s32) from %stack.0)
  ; CHECK-NEXT:   $d1 = COPY [[LOAD3]](s32)
  ; CHECK-NEXT:   RETURN implicit $r0, implicit $d1
  %struct = call %struct.nested @structReturn()
  %res = extractvalue %struct.nested %struct, 2
  ret i32 %res
}
