; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=load-store-vectorizer %s -S -o - | FileCheck %s
target triple="h2blb"

; By default the load store vectorizer is forming loads of <4 x i16>
; in this case.
; When the h2blb TTI is plugged in, we only produce <2 x i16>
define i16 @load_i16x2(ptr %source) {
; CHECK-LABEL: define i16 @load_i16x2(
; CHECK-SAME: ptr [[SOURCE:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i16>, ptr [[SOURCE]], align 8
; CHECK-NEXT:    [[H01:%.*]] = extractelement <2 x i16> [[TMP1]], i32 0
; CHECK-NEXT:    [[H12:%.*]] = extractelement <2 x i16> [[TMP1]], i32 1
; CHECK-NEXT:    [[IDX2:%.*]] = getelementptr inbounds i16, ptr [[SOURCE]], i64 2
; CHECK-NEXT:    [[TMP2:%.*]] = load <2 x i16>, ptr [[IDX2]], align 8
; CHECK-NEXT:    [[H23:%.*]] = extractelement <2 x i16> [[TMP2]], i32 0
; CHECK-NEXT:    [[H34:%.*]] = extractelement <2 x i16> [[TMP2]], i32 1
; CHECK-NEXT:    [[ADD1:%.*]] = add i16 [[H12]], [[H01]]
; CHECK-NEXT:    [[ADD2:%.*]] = add i16 [[H34]], [[H23]]
; CHECK-NEXT:    [[RES:%.*]] = add i16 [[ADD1]], [[ADD2]]
; CHECK-NEXT:    ret i16 [[RES]]
;
  %h0 = load i16, ptr %source, align 8
  %idx1 = getelementptr inbounds i16, ptr %source, i64 1
  %h1 = load i16, ptr %idx1, align 8
  %idx2 = getelementptr inbounds i16, ptr %source, i64 2
  %h2 = load i16, ptr %idx2, align 8
  %idx3 = getelementptr inbounds i16, ptr %source, i64 3
  %h3 = load i16, ptr %idx3, align 8
  %add1 = add i16 %h1, %h0
  %add2 = add i16 %h3, %h2
  %res = add i16 %add1, %add2
  ret i16 %res
}
